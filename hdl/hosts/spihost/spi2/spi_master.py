"""

Based on https://opencores.org/websvn/filedetails?repname=spi_master_slave&path=%2Fspi_master_slave%2Ftrunk%2Frtl%2Fspi_master_slave%2Fspi_master.vhd
--      This block is the SPI master interface, implemented in one single entity.
--      All internal core operations are synchronous to the 'sclk_i', and a spi base clock is generated by dividing sclk_i downto
--      a frequency that is 2x the spi SCK line frequency. The divider value is passed as a generic parameter during instantiation.
--      All parallel i/o interface operations are synchronous to the 'pclk_i' high speed clock, that can be asynchronous to the serial
--      'sclk_i' clock.
--      For optimized use of longlines, connect 'sclk_i' and 'pclk_i' to the same global clock line.
--      Fully pipelined cross-clock circuitry guarantees that no setup artifacts occur on the buffers that are accessed by the two
--      clock domains.
--      The block is very simple to use, and has parallel inputs and outputs that behave like a synchronous memory i/o.
--      It is parameterizable via generics for the data width ('N'), SPI mode (CPHA and CPOL), lookahead prefetch signaling
--      ('PREFETCH'), and spi base clock division from sclk_i ('SPI_2X_CLK_DIV').
--
--      SPI CLOCK GENERATION
--      ====================
--
--      The clock generation for the SPI SCK is derived from the high-speed 'sclk_i' clock. The core divides this reference
--      clock to form the SPI base clock, by the 'SPI_2X_CLK_DIV' generic parameter. The user must set the divider value for the
--      SPI_2X clock, which is 2x the desired SCK frequency.
--      All registers in the core are clocked by the high-speed clocks, and clock enables are used to run the FSM and other logic
--      at lower rates. This architecture preserves FPGA clock resources like global clock buffers, and avoids path delays caused
--      by combinatorial clock dividers outputs.
--      The core has async clock domain circuitry to handle asynchronous clocks for the SPI and parallel interfaces.
--
--      PARALLEL WRITE INTERFACE
--      ========================
--      The parallel interface has an input port 'di_i' and an output port 'do_o'.
--      Parallel load is controlled using 3 signals: 'di_i', 'di_req_o' and 'wren_i'. 'di_req_o' is a look ahead data request line,
--      that is set 'PREFETCH' clock cycles in advance to synchronize a pipelined memory or fifo to present the
--      next input data at 'di_i' in time to have continuous clock at the spi bus, to allow back-to-back continuous load.
--      For a pipelined sync RAM, a PREFETCH of 2 cycles allows an address generator to present the new adress to the RAM in one
--      cycle, and the RAM to respond in one more cycle, in time for 'di_i' to be latched by the shifter.
--      If the user sequencer needs a different value for PREFETCH, the generic can be altered at instantiation time.
--      The 'wren_i' write enable strobe must be valid at least one setup time before the rising edge of the last SPI clock cycle,
--      if continuous transmission is intended. If 'wren_i' is not valid 2 SPI clock cycles after the last transmitted bit, the interface
--      enters idle state and deasserts SSEL.
--      When the interface is idle, 'wren_i' write strobe loads the data and starts transmission. 'di_req_o' will strobe when entering
--      idle state, if a previously loaded data has already been transferred.
--
--      PARALLEL WRITE SEQUENCE
--      =======================
--                         __    __    __    __    __    __    __
--      pclk_i          __/  \__/  \__/  \__/  \__/  \__/  \__/  \...     -- parallel interface clock
--                               ___________
--      di_req_o        ________/           \_____________________...     -- 'di_req_o' asserted on rising edge of 'pclk_i'
--                      ______________ ___________________________...
--      di_i            __old_data____X______new_data_____________...     -- user circuit loads data on 'di_i' at next 'pclk_i' rising edge
--                                                 _______
--      wren_i          __________________________/       \_______...     -- user strobes 'wren_i' for one cycle of 'pclk_i'
--
--
--      PARALLEL READ INTERFACE
--      =======================
--      An internal buffer is used to copy the internal shift register data to drive the 'do_o' port. When a complete word is received,
--      the core shift register is transferred to the buffer, at the rising edge of the spi clock, 'spi_clk'.
--      The signal 'do_valid_o' is set one 'spi_clk' clock after, to directly drive a synchronous memory or fifo write enable.
--      'do_valid_o' is synchronous to the parallel interface clock, and changes only on rising edges of 'pclk_i'.
--      When the interface is idle, data at the 'do_o' port holds the last word received.
--
--      PARALLEL READ SEQUENCE
--      ======================
--                      ______        ______        ______        ______
--      spi_clk          bit1 \______/ bitN \______/bitN-1\______/bitN-2\__...  -- internal spi 2x base clock
--                      _    __    __    __    __    __    __    __    __
--      pclk_i           \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_...  -- parallel interface clock (may be async to sclk_i)
--                      _____________ _____________________________________...  -- 1) rx data is transferred to 'do_buffer_reg'
--      do_o            ___old_data__X__________new_data___________________...  --    after last rx bit, at rising 'spi_clk'.
--                                                   ____________
--      do_valid_o      ____________________________/            \_________...  -- 2) 'do_valid_o' strobed for 2 'pclk_i' cycles
--                                                                              --    on the 3rd 'pclk_i' rising edge.
--
--
--      The propagation delay of spi_sck_o and spi_mosi_o, referred to the internal clock, is balanced by similar path delays,
--      but the sampling delay of spi_miso_i imposes a setup time referred to the sck signal that limits the high frequency
--      of the interface, for full duplex operation.
--
--      This design was originally targeted to a Spartan-6 platform, synthesized with XST and normal constraints.
--      The VHDL dialect used is VHDL'93, accepted largely by all synthesis tools.
--
"""
from myhdl import *


@block
def spi_master(sclk_i, pclk_i, rst_i,
               spi_ssel_o, spi_sck_o, spi_mosi_o, spi_miso_i,
               di_req_o, di_i, wren_i, wr_ack_o, do_valid_o, do_o,
               sck_ena_o, sck_ena_ce_o, do_transfer_o, wren_o, rx_bit_reg_o, state_dbg_o,
               core_clk_o, core_n_clk_o, core_ce_o, core_n_ce_o, sh_reg_dbg_o,
               N=32, CPOL=0, CPHA=0, PREFETCH=2, SPI_2X_CLK_DIV=5
              ):
    """

    :param sclk_i: high - speed serial interface system clock
    :param pclk_i: high - speed parallel interface system clock
    :param rst_i: reset core
    # serial interface
    :param spi_ssel_o: spi bus slave select lcore_n_ce_oine
    :param spi_sck_o: spi bus sck
    :param spi_mosi_o: spi bus mosi output
    :param spi_miso_i: spi bus spi_miso_i input
    # parallel interface
    :param di_req_o: preload lookahead data request line
    :param di_i: parallel data in (clocked on rising spi_clk after last bit)
    :param wren_i: user data write enable, starts transmission when interface is idle
    :param wr_ack_o: write acknowledge
    :param do_valid_o: do_o data valid signal, valid during one spi_clk rising edge
    :param do_o: parallel output (clocked on rising spi_clk after last bit)
    # debug ports: can be removed or left unconnected for the application circuit
    :param sck_ena_o: debug: internal sck enable signal
    :param sck_ena_ce_o: debug: internal sck clock enable signal
    :param do_transfer_o: debug: internal transfer driver
    :param wren_o: debug: internal state of the wren_i pulse stretcher
    :param rx_bit_reg_o: debug: internal rx bit
    :param state_dbg_o: debug: internal state register
    :param core_clk_o:
    :param core_n_clk_o:
    :param core_ce_o:
    :param core_n_ce_o:
    :param sh_reg_dbg_o: debug: internal core_ce_o shift register
    # Generics
    :param N: 32 bit serial word length is default
    :param CPOL: SPI mode selection(mode 0 default)
    :param CPHA: CPOL = clock polarity, CPHA = clock phase.
    :param PREFETCH: prefetch lookahead cycles
    :param SPI_2X_CLK_DIV: for a 100MHz sclk_i, yields a 10MHz SCK
    :return:
    """


    # - -= == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == === == == =
    # -- this architecture is a pipelined register - transfer description.
    # -- all signals are clocked at the rising edge of the system clock 'sclk_i'.
    # - -= == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==  == == == == == == == =
    # core clocks, generated from 'sclk_i': initialized at GSR to differential values signal
    core_clk = Signal(bool(0))  # continuous core clock, positive logic signal
    core_n_clk = Signal(bool(1))  # continuous core clock, negative logic signal
    core_ce = Signal(bool(0))  # core clock enable, positive logic signal
    core_n_ce = Signal(bool(1))  # core clock enable, negative logic

    # spi bus clock, generated from the CPOL selected core clock polarity signal
    spi_2x_ce = Signal(bool(1))  # spi_2x clock enable signal
    spi_clk = Signal(bool(0))  # spi bus output clock signal
    spi_clk_reg = Signal(bool(0))  # output pipeline delay for spi sck(do NOT global initialize)
    # core fsm clock enables
    fsm_ce = Signal(bool(1))  # fsm clock enable signal
    sck_ena_ce = Signal(bool(1))  # SCK clock enable signal
    samp_ce = Signal(bool(1))  # data sampling clock enable

    # GLOBAL RESET:
    # all signals are initialized to zero at GSR(global set / reset) by giving explicit
    # initialization values at declaration.This is needed for all Xilinx FPGAs, and
    # especially for the Spartan - 6 and newer CLB architectures, where a async reset can
    # reduce the usability of the slice registers, due to the need to share the control
    # set(RESET / PRESET, CLOCK ENABLE and CLOCK) by all 8 registers in a slice.
    # By using GSR for the initialization, and reducing async RESET local init to the bare
    # essential, the model achieves better LUT / FF packing and CLB usability.
    #
    # internal state signals for register and combinatorial stages
    state_next = Signal(intbv(0)[N+1:])
    state_reg = Signal(intbv(0)[N+1:])
    # shifter signals for register and combinatorial stages
    sh_next = Signal(intbv(0)[N:])
    sh_reg = Signal(intbv(0)[N:])
    # input bit sampled buffer
    rx_bit_reg = Signal(bool(0))
    # buffered di_i data signals for register and combinatorial stages
    di_reg = Signal(intbv(0)[N:])
    # internal wren_i stretcher for fsm combinatorial stage
    wren = Signal(bool(0))
    wr_ack_next = Signal(bool(0))
    wr_ack_reg = Signal(bool(0))
    # internal SSEL enable control signals
    ssel_ena_next = Signal(bool(0))
    ssel_ena_reg = Signal(bool(0))
    # internal SCK enable control signals
    sck_ena_next = Signal(bool(0))
    sck_ena_reg = Signal(bool(0))
    # buffered do_o data signals for register and combinatorial stages
    do_buffer_next = Signal(intbv(0)[N:])
    do_buffer_reg = Signal(intbv(0)[N:])
    # internal signal to flag transfer to do_buffer_reg
    do_transfer_next = Signal(bool(0))
    do_transfer_reg = Signal(bool(0))
    #  internal input data request signal
    di_req_next = Signal(bool(0))
    di_req_reg = Signal(bool(0))
    # cross-clock do_transfer_reg -> do_valid_o_reg pipeline
    do_valid_A = Signal(bool(0))
    do_valid_B = Signal(bool(0))
    do_valid_C = Signal(bool(0))
    do_valid_D = Signal(bool(0))
    do_valid_next = Signal(bool(0))
    do_valid_o_reg = Signal(bool(0))
    # cross-clock di_req_reg -> di_req_o_reg pipeline
    di_req_o_A = Signal(bool(0))
    di_req_o_B = Signal(bool(0))
    di_req_o_C = Signal(bool(0))
    di_req_o_D = Signal(bool(0))
    di_req_o_next =Signal(bool(1))
    di_req_o_reg = Signal(bool(1))

    clk_cnt = Signal(intbv(0)[SPI_2X_CLK_DIV:])

    # =============================================================================================
    # GENERICS CONSTRAINTS CHECKING
    # =============================================================================================
    # minimum word width is 8 bits
    assert N >= 8, "Generic parameter 'N' (shift register size) needs to be 8 bits minimum"
    # minimum prefetch lookahead check
    assert PREFETCH >= 1, "Generic parameter 'PREFETCH' (lookahead count) needs to be 1 minimum"
    # maximum prefetch lookahead check
    assert PREFETCH <= N-5, "Generic parameter 'PREFETCH' (lookahead count) out of range, needs to be N-5 maximum"
    # SPI_2X_CLK_DIV clock divider value must not be zero
    assert SPI_2X_CLK_DIV > 0, "Generic parameter 'SPI_2X_CLK_DIV' must not be zero"

    # =============================================================================================
    # CLOCK GENERATION
    # =============================================================================================
    # In order to preserve global clocking resources, the core clocking scheme is completely based
    # on using clock enables to process the serial high-speed clock at lower rates for the core fsm,
    # the spi clock generator and the input sampling clock.
    # The clock generation block derives 2 continuous antiphase signals from the 2x spi base clock
    # for the core clocking.
    # The 2 clock phases are generated by separate and synchronous FFs, and should have only
    # differential interconnect delay skew.
    # Clock enable signals are generated with the same phase as the 2 core clocks, and these clock
    # enables are used to control clocking of all internal synchronous circuitry.
    # The clock enable phase is selected for serial input sampling, fsm clocking, and spi SCK output,
    # based on the configuration of CPOL and CPHA.
    # Each phase is selected so that all the registers can be clocked with a rising edge on all SPI
    # modes, by a single high-speed global clock, preserving clock resources and clock to data skew.

    # generate the 2x spi base clock enable from the serial high-speed input clock
    @always(sclk_i.posedge)
    def spi_2x_ce_gen_proc():
        if clk_cnt == SPI_2X_CLK_DIV-1:
            spi_2x_ce.next = True
            clk_cnt.next = 0
        else:
            spi_2x_ce.next = False
            clk_cnt.next = clk_cnt + 1

    # generate the core antiphase clocks and clock enables from the 2x base CE.
    @always(sclk_i.posedge)
    def core_clock_gen_proc():
        if spi_2x_ce:
            # generate the 2 antiphase core clocks
            core_clk.next = core_n_clk
            core_n_clk.next = not core_n_clk
            # generate the 2 phase core clock enables
            core_ce.next = core_n_clk
            core_n_ce.next = not core_n_clk
        else:
            core_ce.next = False
            core_n_ce.next = False

    # =============================================================================================
    # GENERATE BLOCKS
    # =============================================================================================
    # spi clk generator: generate spi_clk from core_clk depending on CPOL
    @always_comb
    def spi_sck_cpol_0_proc():
        if CPOL == 0:
            spi_clk.next = core_clk  # for CPOL=0, spi clk has idle LOW

    @always_comb
    def spi_sck_cpol_1_proc():
        if CPOL == 1:
            spi_clk.next = core_n_clk  # for CPOL=1, spi clk has idle HIGH

    # Sampling clock enable generation: generate 'samp_ce' from 'core_ce' or 'core_n_ce' depending on CPHA
    # always sample data at the half-cycle of the fsm update cell
    @always_comb
    def samp_ce_cpha_0_proc():
        if CPHA == 0:
            samp_ce.next = core_ce

    @always_comb
    def samp_ce_cpha_1_proc():
        if CPHA == 1:
            samp_ce.next = core_n_ce

    # FSM clock enable generation: generate 'fsm_ce' from core_ce or core_n_ce depending on CPHA
    @always_comb
    def fsm_ce_cpha_0_proc():
        if CPHA == 0:
            fsm_ce.next = core_n_ce  # for CPHA=0, latch registers at rising edge of negative core clock enable

    @always_comb
    def fsm_ce_cpha_1_proc():
        if CPHA == 1:
            fsm_ce.next = core_ce  # for CPHA=1, latch registers at rising edge of positive core clock enable

    # sck enable control: control sck advance phase for CPHA='1' relative to fsm clock
    @always_comb
    def comb0():
        sck_ena_ce.next = core_n_ce  # for CPHA=1, SCK is advanced one-half cycle

    # =============================================================================================
    # REGISTERED INPUTS
    # =============================================================================================
    # rx bit flop: capture rx bit after SAMPLE edge of sck
    @always(sclk_i.posedge)
    def rx_bit_proc():
        if samp_ce:
            rx_bit_reg.next = spi_miso_i

    # =============================================================================================
    # CROSS-CLOCK PIPELINE TRANSFER LOGIC
    # =============================================================================================
    # do_valid_o and di_req_o strobe output logic
    # this is a delayed pulse generator with a ripple-transfer FFD pipeline, that generates a
    # fixed-length delayed pulse for the output flags, at the parallel clock domain
    @always(pclk_i.posedge)
    def out_transfer_proc():
        # do_transfer_reg -> do_valid_o_reg
        do_valid_A.next = do_transfer_reg  # the input signal must be at least 2 clocks long
        do_valid_B.next = do_valid_A  # feed it to a ripple chain of FFDs
        do_valid_C.next = do_valid_B
        do_valid_D.next = do_valid_C
        do_valid_o_reg.next = do_valid_next  # registered output. pulse
        # --------------------------------
        # di_req_reg -> di_req_o_reg
        di_req_o_A.next = di_req_reg  # the input signal must be at least 2 clocks long
        di_req_o_B.next = di_req_o_A  # feed it to a ripple chain of FFDs
        di_req_o_C.next = di_req_o_B
        di_req_o_D.next = di_req_o_C
        di_req_o_reg.next = di_req_o_next  # registered output pulse

    @always_comb
    def out_transfer_proc_comb():
        # generate a 2-clocks pulse at the 3rd clock cycle
        do_valid_next.next = do_valid_A and do_valid_B and not do_valid_D
        di_req_o_next.next = di_req_o_A and di_req_o_B and not di_req_o_D

    # parallel load input registers: data register and write enable
    @always(pclk_i.posedge)
    def in_transfer_proc():
        # registered data input, input register with clock enable
        if wren_i:
            di_reg.next = di_i  # parallel data input buffer register
        # stretch wren pulse to be detected by spi fsm (ffd with sync preset and sync reset)
        if wren_i:  # wren_i is the sync preset for wren
            wren.next = True
        elif wr_ack_reg:  # wr_ack is the sync reset for wren
            wren.next = False

    # =============================================================================================
    # REGISTER TRANSFER PROCESSES
    # =============================================================================================
    # fsm state and data registers: synchronous to the spi base reference clock
    @always(sclk_i.posedge)
    def core_reg_proc():
        # FF registers clocked on rising edge and cleared on sync rst_i
        if rst_i:  # sync reset
            state_reg.next = 0  # only provide local reset for the state machine
        elif fsm_ce:  # fsm_ce is clock enable for the fsm
            state_reg.next = state_next  # state register

        # FF registers clocked synchronous to the fsm state
        if fsm_ce:
            sh_reg.next = sh_next  # shift register
            ssel_ena_reg.next = ssel_ena_next  # spi select enable
            do_buffer_reg.next = do_buffer_next  # registered output data buffer
            do_transfer_reg.next = do_transfer_next  # output data transferred to buffer
            di_req_reg.next = di_req_next  # input data request
            wr_ack_reg.next = wr_ack_next  # write acknowledge for data load synchronization

        # FF registers clocked one-half cycle earlier than the fsm state
        if sck_ena_ce:
            sck_ena_reg.next = sck_ena_next  # spi clock enable: look ahead logic

    # =============================================================================================
    # COMBINATORIAL LOGIC PROCESSES
    # =============================================================================================
    # state and datapath combinatorial logic
    @always_comb
    def core_combi_proc():
        sh_next.next = sh_reg  # all output signals are assigned to (avoid latches)
        ssel_ena_next.next = ssel_ena_reg  # controls the slave select line
        sck_ena_next.next = sck_ena_reg  # controls the clock enable of spi sck line
        do_buffer_next.next = do_buffer_reg  # output data buffer
        do_transfer_next.next = do_transfer_reg  # output data flag
        wr_ack_next.next = wr_ack_reg  # write acknowledge
        di_req_next.next = di_req_reg  # prefetch data request
        spi_mosi_o.next = sh_reg[N - 1]  # default to avoid latch inference
        state_next.next = state_reg  # next state
        if state_reg == N+1:  # this state is to enable SSEL before SCK
            spi_mosi_o.next = sh_reg[N-1]  # shift out tx bit from the MSb
            ssel_ena_next.next = True  # tx in progress: will assert SSEL
            sck_ena_next.next = True  # enable SCK on next cycle (stays off on first SSEL clock cycle)
            di_req_next.next = False  # prefetch data request: deassert when shifting data
            wr_ack_next.next = False  # remove write acknowledge for all but the load stages
            state_next.next = state_reg - 1  # update next state at each sck pulse
        elif state_reg == N:  # deassert 'di_rdy' and stretch do_valid
            spi_mosi_o.next = sh_reg[N-1]  # shift out tx bit from the MSb
            di_req_next.next = False  # prefetch data request: deassert when shifting data
            sh_next.next[N:1] = sh_reg[N-1:0]  # shift inner bits
            sh_next.next[0] = rx_bit_reg  # shift in rx bit into LSb
            wr_ack_next.next = False  # remove write acknowledge for all but the load stages
            state_next.next = state_reg - 1  # update next state at each sck pulse
        # elif int(state_reg.val) in [i for i in range(PREFETCH + 3, N - 1)]:  # remove 'do_transfer' and shift bits
        elif state_reg >= PREFETCH + 3 and state_reg <= (N - 1):  # remove 'do_transfer' and shift bits
            spi_mosi_o.next = sh_reg[N-1]  # shift out tx bit from the MSb
            di_req_next.next = False  # prefetch data request: deassert when shifting data
            do_transfer_next.next = False  # reset 'do_valid' transfer signal
            sh_next.next[N:1] = sh_reg[N-1:0]  # shift inner bits
            sh_next.next[0] = rx_bit_reg  # shift in rx bit into LSb
            wr_ack_next.next = False  # remove write acknowledge for all but the load stages
            state_next.next = state_reg - 1  # update next state at each sck pulse
        # elif int(state_reg.val) in [i for i in range(2, PREFETCH + 2)]:  # raise prefetch 'di_req_o' signal
        elif state_reg >= 2 and state_reg <= (PREFETCH + 2):  # raise prefetch 'di_req_o' signal
            spi_mosi_o.next = sh_reg[N-1]  # shift out tx bit from the MSb
            di_req_next.next = True  # request data in advance to allow for pipeline delays
            sh_next.next[N:1] = sh_reg[N-1:0]  # shift inner bits
            sh_next.next[0] = rx_bit_reg  # shift in rx bit into LSb
            wr_ack_next.next = False  # remove write acknowledge for all but the load stages
            state_next.next = state_reg - 1  # update next state at each sck pulse
        elif state_reg == 1:  # transfer rx data to do_buffer and restart if new data is written
            spi_mosi_o.next = sh_reg[N-1]  # shift out tx bit from the MSb
            di_req_next.next = True  # request data in advance to allow for pipeline delays
            do_buffer_next.next[N:1] = sh_reg[N-1:0]  # shift rx data directly into rx buffer
            do_buffer_next.next[0] = rx_bit_reg  # shift last rx bit into rx buffer
            do_transfer_next.next = True  # signal transfer to do_buffer
            if wren:  # load tx register if valid data present at di_i
                state_next.next = N  # next state is top bit of new data
                sh_next.next = di_reg  # load parallel data from di_reg into shifter
                sck_ena_next.next = True  # SCK enabled
                wr_ack_next.next = True  # acknowledge data in transfer
            else:
                sck_ena_next.next = False  # SCK disabled: tx empty, no data to send
                wr_ack_next.next = False  # remove write acknowledge for all but the load stages
                state_next.next = state_reg - 1  # update next state at each sck pulse
        elif state_reg == 0:  # idle state: start and end of transmission
            di_req_next.next = True  # will request data if shifter empty
            sck_ena_next.next = False  # SCK disabled: tx empty, no data to send
            if wren:  # load txrx_bit_reg register if valid data present at di_i
                spi_mosi_o.next = di_reg[N-1]  # special case: shift out first tx bit from the MSb (look ahead)
                ssel_ena_next.next = True  # enable interface SSEL
                state_next.next = N+1  # start from idle: let one cycle for SSEL settling
                sh_next.next = di_reg  # load bits from di_reg into shifter
                wr_ack_next.next = True  # acknowledge data in transfer
            else:
                spi_mosi_o.next = sh_reg[N-1]  # shift out tx bit from the MSb
                ssel_ena_next.next = False  # deassert SSEL: interface is idle
                wr_ack_next.next = False  # remove write acknowledge for all but the load stages
                state_next.next = 0  # when idle, keep this state
        else:
            state_next.next = 0  # state 0 is safe state

    # =============================================================================================
    # OUTPUT LOGIC PROCESSES
    # =============================================================================================
    # data output processes
    @always_comb
    def comb1():
        # spi_ssel_o_proc
        spi_ssel_o.next = not ssel_ena_reg  # active-low slave select line
        # do_o_proc
        do_o.next = do_buffer_reg  # parallel data out
        # do_valid_o_proc
        do_valid_o.next = do_valid_o_reg  # data out valid
        # di_req_o_proc
        di_req_o.next = di_req_o_reg  # input data request for next cycle
        # wr_ack_o_proc
        wr_ack_o.next = wr_ack_reg  # write acknowledge

    # SCK out logic: pipeline phase compensation for the SCK line
    # This is a MUX with an output register.
    # The register gives us a pipeline delay for the SCK line, pairing with the state machine moore
    # output pipeline delay for the MOSI line, and thus enabling higher SCK frequency.
    @always(sclk_i.posedge)
    def spi_sck_o_gen_proc():
        if sck_ena_reg:
            spi_clk_reg.next = spi_clk  # copy the selected clock polarity
        else:
            spi_clk_reg.next = CPOL  # when clock disabled, set to idle polarity

    @always_comb
    def comb2():
        spi_sck_o.next = spi_clk_reg  # connect register to output

    # =============================================================================================
    # DEBUG LOGIC PROCESSES
    # =============================================================================================
    # these signals are useful for verification, and can be deleted after debug.
    @always_comb
    def comb3():
        do_transfer_o.next = do_transfer_reg
        state_dbg_o.next = state_reg
        rx_bit_reg_o.next = rx_bit_reg
        wren_o.next = wren
        sh_reg_dbg_o.next = sh_reg
        core_clk_o.next = core_clk
        core_n_clk_o.next = core_n_clk
        core_ce_o.next = core_ce
        core_n_ce_o.next = core_n_ce
        sck_ena_o.next = sck_ena_reg
        sck_ena_ce_o.next = sck_ena_ce

    return spi_2x_ce_gen_proc, \
           core_clock_gen_proc, \
           spi_sck_cpol_0_proc, \
           spi_sck_cpol_1_proc, \
           spi_sck_o_gen_proc, \
           samp_ce_cpha_0_proc, \
           samp_ce_cpha_1_proc, \
           fsm_ce_cpha_0_proc, \
           fsm_ce_cpha_1_proc, \
           comb0, \
           rx_bit_proc, \
           out_transfer_proc, \
           out_transfer_proc_comb, \
           in_transfer_proc, \
           core_reg_proc, \
           core_combi_proc, \
           comb1, \
           comb2, \
           comb3








