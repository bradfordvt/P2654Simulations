"""
/**********************************************************************************
*                                                                                 *
*  This verilog file is a part of the Boundary Scan Implementation and comes in   *
*  a pack with several other files. It is fully IEEE 1149.1 compliant.            *
*  For details check www.opencores.org (pdf files, bsdl file, etc.)               *
*                                                                                 *
*  Copyright (C) 2000 Igor Mohor (igorm@opencores.org) and OPENCORES.ORG          *
*                                                                                 *
*  This program is free software; you can redistribute it and/or modify           *
*  it under the terms of the GNU General Public License as published by           *
*  the Free Software Foundation; either version 2 of the License, or              *
*  (at your option) any later version.                                            *
*                                                                                 *
*  See the file COPYING for the full details of the license.                      *
*                                                                                 *
*  OPENCORES.ORG is looking for new open source IP cores and developers that      *
*  would like to help in our mission.                                             *
*                                                                                 *
**********************************************************************************/


/**********************************************************************************
*                                                                                 *
*	  I/O Control Cell:                                                             *
*                                                                                 *
*	  OutputControl: Output Control from on-chip logic                              *
*	  FromPreviousBSCell: Value from previous boundary scan cell                    *
*	  ToNextBSCell: Value for next boundary scan cell                               *
*	  CaptureDR, ShiftDR, UpdateDR: TAP states                                      *
*	  extest: Instruction Register Command                                          *
*	  TCK: Test Clock                                                               *
*                                                                                 *
*	  Output Enable can be generated by running CaptureDR-UpdateDR sequence	or      *
*	  shifting data for the exact number of time                                    *
*                                                                                 *
**********************************************************************************/
"""
from myhdl import  *


# This is not a top module
class ControlCell:
    def __init__(self, OutputControl, FromPreviousBSCell, CaptureDR, ShiftDR, UpdateDR,
                 extest, TCK, ToNextBSCell, ToOutputEnable):
        self.OutputControl = OutputControl
        self.FromPreviousBSCell = FromPreviousBSCell
        self.CaptureDR = CaptureDR
        self.ShiftDR = ShiftDR
        self.UpdateDR = UpdateDR
        self.extest = extest
        self.TCK = TCK
        self.ToNextBSCell = ToNextBSCell
        self.ToOutputEnable = ToOutputEnable
        self.tms = None
        self.trst = None

    def configure_jtag(self, tdi, tck, tms, trst, tdo):
        # self.FromPreviousBSCell = tdi
        # self.TCK = tck
        self.tms = tms
        self.trst = trst
        # self.ToNextBSCell = tdo

    @block
    def rtl(self):
        Latch = Signal(bool(0))
        ShiftedControl = Signal(bool(0))
        SelectedInput = Signal(bool(0))

        @always_comb
        def sel_process():
            if self.CaptureDR:
                SelectedInput.next = self.OutputControl
            else:
                SelectedInput.next = self.FromPreviousBSCell

        @always(self.TCK.posedge)
        def latch_logic():
            if self.CaptureDR or self.ShiftDR:
                Latch.next = SelectedInput
            else:
                Latch.next = Latch

        @always(self.TCK.negedge)
        def to_logic():
            self.ToNextBSCell.next = Latch

        @always(self.TCK.negedge)
        def update_logic():
            if self.UpdateDR:
                ShiftedControl.next = self.ToNextBSCell

        @always_comb
        def ena_process():
            if self.extest:
                self.ToOutputEnable.next = ShiftedControl
            else:
                self.ToOutputEnable.next = self.OutputControl
        return sel_process, latch_logic, to_logic, update_logic, ena_process
